{"version":3,"sources":["Pager.tsx"],"names":["React","StyleSheet","TextInput","Keyboard","I18nManager","InteractionManager","Text","PanGestureHandler","State","Animated","Easing","OldEasing","EasingNode","memoize","Clock","Value","onChange","and","or","abs","add","block","call","ceil","clockRunning","cond","divide","eq","event","floor","greaterThan","lessThan","max","min","multiply","neq","not","round","set","spring","startClock","stopClock","sub","timing","PagerContext","createContext","TRUE","FALSE","NOOP","UNSET","DIRECTION_LEFT","DIRECTION_RIGHT","SWIPE_DISTANCE_MINIMUM","SWIPE_VELOCITY_IMPACT","SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","SPRING_VELOCITY_SCALE","TIMING_CONFIG","duration","easing","out","cubic","Pager","Component","enabled","childPanGestureHandlerRefs","addGestureHandlerRef","ref","state","includes","mounted","setState","prevState","createRef","UNDETERMINED","props","navigationState","index","layout","width","routes","length","swipeVelocityImpact","undefined","springVelocityScale","layoutWidth","progress","springConfig","timingConfig","isSwipeGesture","setValue","nextIndex","key","keyboardDismissMode","onIndexChange","findIndex","route","jumpToIndex","dismiss","type","listener","enterListeners","push","indexOf","splice","value","Math","forEach","toValue","frameTime","position","time","finished","clock","isRTL","initialVelocityForSpring","velocityX","velocity","gestureX","nativeEvent","translationX","gestureState","gesturesEnabled","routesLength","toggleEnabled","currentIndexValue","pendingIndexValue","forceUpdate","lastEnteredIndex","handleEnteredIndexChange","isSwiping","indexAtSwipeEnd","currentIndex","onSwipeStart","onSwipeEnd","interactionHandle","createInteractionHandle","input","currentlyFocusedInput","currentlyFocusedField","blurTextInput","previouslyFocusedTextInput","clearInteractionHandle","focusTextInput","ACTIVE","maybeCancel","offsetX","transitionTo","extrapolatedPosition","translateX","componentDidMount","context","gestureHandlerRef","componentDidUpdate","prevProps","componentWillUnmount","render","swipeEnabled","children","removeClippedSubviews","gestureHandlerProps","getTranslateX","animatedView","styles","container","transform","providerVal","contentView","handleGestureEvent","addListener","removeListener","jumpTo","create","flex","flexDirection"],"mappings":"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","sourcesContent":["import * as React from 'react';\r\nimport {\r\n  StyleSheet,\r\n  TextInput,\r\n  Keyboard,\r\n  I18nManager,\r\n  InteractionManager,\r\n  Text,\r\n} from 'react-native';\r\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\r\nimport Animated, {\r\n  Easing as OldEasing,\r\n  // @ts-ignore\r\n  EasingNode,\r\n} from 'react-native-reanimated';\r\nimport memoize from './memoize';\r\n\r\nimport {\r\n  Layout,\r\n  NavigationState,\r\n  Route,\r\n  Listener,\r\n  PagerCommonProps,\r\n  EventEmitterProps,\r\n} from './types';\r\n\r\ntype Binary = 0 | 1;\r\n\r\nconst Easing = EasingNode || OldEasing;\r\n\r\nexport type Props<T extends Route> = PagerCommonProps & {\r\n  onIndexChange: (index: number) => void;\r\n  navigationState: NavigationState<T>;\r\n  layout: Layout;\r\n  // Clip unfocused views to improve memory usage\r\n  // Don't enable this on iOS where this is buggy and views don't re-appear\r\n  removeClippedSubviews?: boolean;\r\n  children: (\r\n    props: EventEmitterProps & {\r\n      // Animated value which represents the state of current index\r\n      // It can include fractional digits as it represents the intermediate value\r\n      position: Animated.Node<number>;\r\n      // Function to actually render the content of the pager\r\n      // The parent component takes care of rendering\r\n      render: (children: React.ReactNode) => React.ReactNode;\r\n      // Callback to call when switching the tab\r\n      // The tab switch animation is performed even if the index in state is unchanged\r\n      jumpTo: (key: string) => void;\r\n    }\r\n  ) => React.ReactNode;\r\n  gestureHandlerProps: React.ComponentProps<typeof PanGestureHandler>;\r\n};\r\n\r\ntype ComponentState = {\r\n  enabled: boolean;\r\n  childPanGestureHandlerRefs: React.RefObject<PanGestureHandler>[];\r\n};\r\n\r\nconst {\r\n  Clock,\r\n  Value,\r\n  onChange,\r\n  and,\r\n  or,\r\n  abs,\r\n  add,\r\n  block,\r\n  call,\r\n  ceil,\r\n  clockRunning,\r\n  cond,\r\n  divide,\r\n  eq,\r\n  event,\r\n  floor,\r\n  greaterThan,\r\n  lessThan,\r\n  max,\r\n  min,\r\n  multiply,\r\n  neq,\r\n  not,\r\n  round,\r\n  set,\r\n  spring,\r\n  startClock,\r\n  stopClock,\r\n  sub,\r\n  timing,\r\n} = Animated;\r\n\r\nconst PagerContext = React.createContext({});\r\n\r\nconst TRUE = 1;\r\nconst FALSE = 0;\r\nconst NOOP = 0;\r\nconst UNSET = -1;\r\n\r\nconst DIRECTION_LEFT = 1;\r\nconst DIRECTION_RIGHT = -1;\r\n\r\nconst SWIPE_DISTANCE_MINIMUM = 20;\r\n\r\nconst SWIPE_VELOCITY_IMPACT = 0.2;\r\n\r\nconst SPRING_CONFIG = {\r\n  stiffness: 1000,\r\n  damping: 500,\r\n  mass: 3,\r\n  overshootClamping: true,\r\n  restDisplacementThreshold: 0.01,\r\n  restSpeedThreshold: 0.01,\r\n};\r\n\r\nconst SPRING_VELOCITY_SCALE = 1;\r\n\r\nconst TIMING_CONFIG = {\r\n  duration: 200,\r\n  easing: Easing.out(Easing.cubic),\r\n};\r\n\r\nexport default class Pager<T extends Route> extends React.Component<\r\n  Props<T>,\r\n  ComponentState\r\n> {\r\n  static defaultProps = {\r\n    swipeVelocityImpact: SWIPE_VELOCITY_IMPACT,\r\n    springVelocityScale: SPRING_VELOCITY_SCALE,\r\n  };\r\n\r\n  state = {\r\n    enabled: true,\r\n    childPanGestureHandlerRefs: [] as React.RefObject<PanGestureHandler>[],\r\n  };\r\n\r\n  componentDidMount() {\r\n    this.mounted = true;\r\n\r\n    // Register this PanGestureHandler with the parent (if parent exists)\r\n    // in order to coordinate gestures between handlers.\r\n    if (this.context && this.context.addGestureHandlerRef) {\r\n      this.context.addGestureHandlerRef(this.gestureHandlerRef);\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(prevProps: Props<T>) {\r\n    const {\r\n      navigationState,\r\n      layout,\r\n      swipeVelocityImpact,\r\n      springVelocityScale,\r\n      springConfig,\r\n      timingConfig,\r\n    } = this.props;\r\n    const { index, routes } = navigationState;\r\n\r\n    if (\r\n      // Check for index in state to avoid unintended transition if component updates during swipe\r\n      (index !== prevProps.navigationState.index &&\r\n        index !== this.currentIndexValue) ||\r\n      // Check if the user updated the index correctly after an update\r\n      (typeof this.pendingIndexValue === 'number' &&\r\n        index !== this.pendingIndexValue)\r\n    ) {\r\n      // Index in user's state is different from the index being tracked\r\n      this.jumpToIndex(index);\r\n    }\r\n\r\n    // Reset the pending index\r\n    this.pendingIndexValue = undefined;\r\n\r\n    // Update our mappings of animated nodes when props change\r\n    if (prevProps.navigationState.routes.length !== routes.length) {\r\n      this.routesLength.setValue(routes.length);\r\n    }\r\n\r\n    if (prevProps.layout.width !== layout.width) {\r\n      this.progress.setValue(-index * layout.width);\r\n      this.layoutWidth.setValue(layout.width);\r\n    }\r\n\r\n    if (prevProps.swipeVelocityImpact !== swipeVelocityImpact) {\r\n      this.swipeVelocityImpact.setValue(\r\n        swipeVelocityImpact !== undefined\r\n          ? swipeVelocityImpact\r\n          : SWIPE_VELOCITY_IMPACT\r\n      );\r\n    }\r\n\r\n    if (prevProps.springVelocityScale !== springVelocityScale) {\r\n      this.springVelocityScale.setValue(\r\n        springVelocityScale !== undefined\r\n          ? springVelocityScale\r\n          : SPRING_VELOCITY_SCALE\r\n      );\r\n    }\r\n\r\n    if (prevProps.springConfig !== springConfig) {\r\n      this.springConfig.damping.setValue(\r\n        springConfig.damping !== undefined\r\n          ? springConfig.damping\r\n          : SPRING_CONFIG.damping\r\n      );\r\n\r\n      this.springConfig.mass.setValue(\r\n        springConfig.mass !== undefined ? springConfig.mass : SPRING_CONFIG.mass\r\n      );\r\n\r\n      this.springConfig.stiffness.setValue(\r\n        springConfig.stiffness !== undefined\r\n          ? springConfig.stiffness\r\n          : SPRING_CONFIG.stiffness\r\n      );\r\n\r\n      this.springConfig.restSpeedThreshold.setValue(\r\n        springConfig.restSpeedThreshold !== undefined\r\n          ? springConfig.restSpeedThreshold\r\n          : SPRING_CONFIG.restSpeedThreshold\r\n      );\r\n\r\n      this.springConfig.restDisplacementThreshold.setValue(\r\n        springConfig.restDisplacementThreshold !== undefined\r\n          ? springConfig.restDisplacementThreshold\r\n          : SPRING_CONFIG.restDisplacementThreshold\r\n      );\r\n    }\r\n\r\n    if (prevProps.timingConfig !== timingConfig) {\r\n      this.timingConfig.duration.setValue(\r\n        timingConfig.duration !== undefined\r\n          ? timingConfig.duration\r\n          : TIMING_CONFIG.duration\r\n      );\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.mounted = false;\r\n\r\n    if (this.interactionHandle !== null) {\r\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\r\n    }\r\n  }\r\n\r\n  mounted = false;\r\n\r\n  static contextType = PagerContext;\r\n\r\n  // Mechanism to add child PanGestureHandler refs in the case that this\r\n  // Pager is a parent to child Pagers. Allows for coordination between handlers\r\n  private providerVal = {\r\n    addGestureHandlerRef: (ref: React.RefObject<PanGestureHandler>) => {\r\n      if (\r\n        !this.state.childPanGestureHandlerRefs.includes(ref) &&\r\n        this.mounted\r\n      ) {\r\n        this.setState((prevState: ComponentState) => ({\r\n          childPanGestureHandlerRefs: [\r\n            ...prevState.childPanGestureHandlerRefs,\r\n            ref,\r\n          ],\r\n        }));\r\n      }\r\n    },\r\n  };\r\n\r\n  // PanGestureHandler ref used for coordination with parent handlers\r\n  private gestureHandlerRef: React.RefObject<\r\n    PanGestureHandler\r\n  > = React.createRef();\r\n\r\n  // Clock used for tab transition animations\r\n  private clock = new Clock();\r\n\r\n  // Current state of the gesture\r\n  private velocityX = new Value(0);\r\n  private gestureX = new Value(0);\r\n  private gestureState = new Value(State.UNDETERMINED);\r\n  private offsetX = new Value(0);\r\n\r\n  // Tracks current state of gesture handler enabled\r\n  private gesturesEnabled = new Value(1);\r\n\r\n  // Current progress of the page (translateX value)\r\n  private progress = new Value(\r\n    // Initial value is based on the index and page width\r\n    this.props.navigationState.index * this.props.layout.width * DIRECTION_RIGHT\r\n  );\r\n\r\n  // Initial index of the tabs\r\n  private index = new Value(this.props.navigationState.index);\r\n\r\n  // Next index of the tabs, updated for navigation from outside (tab press, state update)\r\n  private nextIndex: Animated.Value<number> = new Value(UNSET);\r\n\r\n  // Scene that was last entered\r\n  private lastEnteredIndex = new Value(this.props.navigationState.index);\r\n\r\n  // Whether the user is currently dragging the screen\r\n  private isSwiping: Animated.Value<Binary> = new Value(FALSE);\r\n\r\n  // Whether the update was due to swipe gesture\r\n  // This controls whether the transition will use a spring or timing animation\r\n  // Remember to set it before transition needs to occur\r\n  private isSwipeGesture: Animated.Value<Binary> = new Value(FALSE);\r\n\r\n  // Track the index value when a swipe gesture has ended\r\n  // This lets us know if a gesture end triggered a tab switch or not\r\n  private indexAtSwipeEnd: Animated.Value<number> = new Value(\r\n    this.props.navigationState.index\r\n  );\r\n\r\n  // Mappings to some prop values\r\n  // We use them in animation calculations, so we need live animated nodes\r\n  private routesLength = new Value(this.props.navigationState.routes.length);\r\n  private layoutWidth = new Value(this.props.layout.width);\r\n\r\n  // Determines how relevant is a velocity while calculating next position while swiping\r\n  private swipeVelocityImpact = new Value(\r\n    this.props.swipeVelocityImpact !== undefined\r\n      ? this.props.swipeVelocityImpact\r\n      : SWIPE_VELOCITY_IMPACT\r\n  );\r\n\r\n  private springVelocityScale = new Value(\r\n    this.props.springVelocityScale !== undefined\r\n      ? this.props.springVelocityScale\r\n      : SPRING_VELOCITY_SCALE\r\n  );\r\n\r\n  // The position value represent the position of the pager on a scale of 0 - routes.length-1\r\n  // It is calculated based on the translate value and layout width\r\n  // If we don't have the layout yet, we should return the current index\r\n  private position = cond(\r\n    this.layoutWidth,\r\n    divide(multiply(this.progress, -1), this.layoutWidth),\r\n    this.index\r\n  );\r\n\r\n  // Animation configuration\r\n  private springConfig = {\r\n    damping: new Value(\r\n      this.props.springConfig.damping !== undefined\r\n        ? this.props.springConfig.damping\r\n        : SPRING_CONFIG.damping\r\n    ),\r\n    mass: new Value(\r\n      this.props.springConfig.mass !== undefined\r\n        ? this.props.springConfig.mass\r\n        : SPRING_CONFIG.mass\r\n    ),\r\n    stiffness: new Value(\r\n      this.props.springConfig.stiffness !== undefined\r\n        ? this.props.springConfig.stiffness\r\n        : SPRING_CONFIG.stiffness\r\n    ),\r\n    restSpeedThreshold: new Value(\r\n      this.props.springConfig.restSpeedThreshold !== undefined\r\n        ? this.props.springConfig.restSpeedThreshold\r\n        : SPRING_CONFIG.restSpeedThreshold\r\n    ),\r\n    restDisplacementThreshold: new Value(\r\n      this.props.springConfig.restDisplacementThreshold !== undefined\r\n        ? this.props.springConfig.restDisplacementThreshold\r\n        : SPRING_CONFIG.restDisplacementThreshold\r\n    ),\r\n  };\r\n\r\n  private timingConfig = {\r\n    duration: new Value(\r\n      this.props.timingConfig.duration !== undefined\r\n        ? this.props.timingConfig.duration\r\n        : TIMING_CONFIG.duration\r\n    ),\r\n  };\r\n\r\n  // The reason for using this value instead of simply passing `this._velocity`\r\n  // into a spring animation is that we need to reverse it if we're using RTL mode.\r\n  // Also, it's not possible to pass multiplied value there, because\r\n  // value passed to STATE of spring (the first argument) has to be Animated.Value\r\n  // and it's not allowed to pass other nodes there. The result of multiplying is not an\r\n  // Animated.Value. So this value is being updated on each start of spring animation.\r\n  private initialVelocityForSpring = new Value(0);\r\n\r\n  // The current index change caused by the pager's animation\r\n  // The pager is used as a controlled component\r\n  // We need to keep track of the index to determine when to trigger animation\r\n  // The state will change at various points, we should only respond when we are out of sync\r\n  // This will ensure smoother animation and avoid weird glitches\r\n  private currentIndexValue = this.props.navigationState.index;\r\n\r\n  // The pending index value as result of state update caused by swipe gesture\r\n  // We need to set it when state changes from inside this component\r\n  // It also needs to be reset right after componentDidUpdate fires\r\n  private pendingIndexValue: number | undefined = undefined;\r\n\r\n  // Numeric id of the previously focused text input\r\n  // When a gesture didn't change the tab, we can restore the focused input with this\r\n  private previouslyFocusedTextInput: number | null = null;\r\n\r\n  // Listeners for the entered screen\r\n  private enterListeners: Listener[] = [];\r\n\r\n  // InteractionHandle to handle tasks around animations\r\n  private interactionHandle: number | null = null;\r\n\r\n  private jumpToIndex = (index: number) => {\r\n    // If the index changed, we need to trigger a tab switch\r\n    this.isSwipeGesture.setValue(FALSE);\r\n    this.nextIndex.setValue(index);\r\n  };\r\n\r\n  private jumpTo = (key: string) => {\r\n    const { navigationState, keyboardDismissMode, onIndexChange } = this.props;\r\n\r\n    const index = navigationState.routes.findIndex(\r\n      (route) => route.key === key\r\n    );\r\n\r\n    // A tab switch might occur when we're in the middle of a transition\r\n    // In that case, the index might be same as before\r\n    // So we conditionally make the pager to update the position\r\n    if (navigationState.index === index) {\r\n      this.jumpToIndex(index);\r\n    } else {\r\n      onIndexChange(index);\r\n\r\n      // When the index changes, the focused input will no longer be in current tab\r\n      // So we should dismiss the keyboard\r\n      if (keyboardDismissMode === 'auto') {\r\n        Keyboard.dismiss();\r\n      }\r\n    }\r\n  };\r\n\r\n  private addListener = (type: 'enter', listener: Listener) => {\r\n    switch (type) {\r\n      case 'enter':\r\n        this.enterListeners.push(listener);\r\n        break;\r\n    }\r\n  };\r\n\r\n  private removeListener = (type: 'enter', listener: Listener) => {\r\n    switch (type) {\r\n      case 'enter': {\r\n        const index = this.enterListeners.indexOf(listener);\r\n\r\n        if (index > -1) {\r\n          this.enterListeners.splice(index, 1);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  private handleEnteredIndexChange = ([value]: readonly number[]) => {\r\n    const index = Math.max(\r\n      0,\r\n      Math.min(value, this.props.navigationState.routes.length - 1)\r\n    );\r\n\r\n    this.enterListeners.forEach((listener) => listener(index));\r\n  };\r\n\r\n  private transitionTo = (index: Animated.Node<number>) => {\r\n    const toValue = new Value(0);\r\n    const frameTime = new Value(0);\r\n\r\n    const state = {\r\n      position: this.progress,\r\n      time: new Value(0),\r\n      finished: new Value(FALSE),\r\n    };\r\n\r\n    return block([\r\n      cond(clockRunning(this.clock), NOOP, [\r\n        // Animation wasn't running before\r\n        // Set the initial values and start the clock\r\n        set(toValue, multiply(index, this.layoutWidth, DIRECTION_RIGHT)),\r\n        set(frameTime, 0),\r\n        set(state.time, 0),\r\n        set(state.finished, FALSE),\r\n        set(this.index, index),\r\n      ]),\r\n      cond(\r\n        this.isSwipeGesture,\r\n        // Animate the values with a spring for swipe\r\n        [\r\n          cond(\r\n            not(clockRunning(this.clock)),\r\n            I18nManager.isRTL\r\n              ? set(\r\n                  this.initialVelocityForSpring,\r\n                  multiply(-1, this.velocityX, this.springVelocityScale)\r\n                )\r\n              : set(\r\n                  this.initialVelocityForSpring,\r\n                  multiply(this.velocityX, this.springVelocityScale)\r\n                )\r\n          ),\r\n          spring(\r\n            this.clock,\r\n            { ...state, velocity: this.initialVelocityForSpring },\r\n            { ...SPRING_CONFIG, ...this.springConfig, toValue }\r\n          ),\r\n        ],\r\n        // Otherwise use a timing animation for faster switching\r\n        timing(\r\n          this.clock,\r\n          { ...state, frameTime },\r\n          { ...TIMING_CONFIG, ...this.timingConfig, toValue }\r\n        )\r\n      ),\r\n      cond(not(clockRunning(this.clock)), startClock(this.clock)),\r\n      cond(state.finished, [\r\n        // Reset values\r\n        set(this.isSwipeGesture, FALSE),\r\n        set(this.gestureX, 0),\r\n        set(this.velocityX, 0),\r\n        // When the animation finishes, stop the clock\r\n        stopClock(this.clock),\r\n      ]),\r\n    ]);\r\n  };\r\n\r\n  private handleGestureEvent = event([\r\n    {\r\n      nativeEvent: {\r\n        translationX: this.gestureX,\r\n        velocityX: this.velocityX,\r\n        state: this.gestureState,\r\n      },\r\n    },\r\n  ]);\r\n\r\n  private extrapolatedPosition = add(\r\n    this.gestureX,\r\n    multiply(this.velocityX, this.swipeVelocityImpact)\r\n  );\r\n\r\n  private toggleEnabled = () => {\r\n    if (this.state.enabled && this.mounted)\r\n      this.setState({ enabled: false }, () => {\r\n        this.setState({ enabled: true });\r\n      });\r\n  };\r\n\r\n  // Cancel gesture if swiping back from the initial tab or forward from the last tab.\r\n  // Enables parent Pager to pick up the gesture if one exists.\r\n  private maybeCancel = block([\r\n    cond(\r\n      and(\r\n        this.gesturesEnabled,\r\n        or(\r\n          and(\r\n            eq(this.index, sub(this.routesLength, 1)),\r\n            lessThan(this.gestureX, 0)\r\n          ),\r\n          and(eq(this.index, 0), greaterThan(this.gestureX, 0))\r\n        )\r\n      ),\r\n      set(this.gesturesEnabled, 0)\r\n    ),\r\n  ]);\r\n\r\n  private translateX = block([\r\n    onChange(\r\n      this.gesturesEnabled,\r\n      cond(\r\n        not(this.gesturesEnabled),\r\n        call([this.gesturesEnabled], this.toggleEnabled)\r\n      )\r\n    ),\r\n    onChange(\r\n      this.index,\r\n      call([this.index], ([value]) => {\r\n        this.currentIndexValue = value;\r\n        // Without this check, the pager can go to an infinite update <-> animate loop for sync updates\r\n        if (value !== this.props.navigationState.index) {\r\n          // If the index changed, and previous animation has finished, update state\r\n          this.props.onIndexChange(value);\r\n\r\n          this.pendingIndexValue = value;\r\n\r\n          // Force componentDidUpdate to fire, whether user does a setState or not\r\n          // This allows us to detect when the user drops the update and revert back\r\n          // It's necessary to make sure that the state stays in sync\r\n          if (this.mounted) {\r\n            this.forceUpdate();\r\n          }\r\n        }\r\n      })\r\n    ),\r\n    onChange(\r\n      this.position,\r\n      // Listen to updates in the position to detect when we enter a screen\r\n      // This is useful for things such as lazy loading when index change will fire too late\r\n      cond(\r\n        I18nManager.isRTL\r\n          ? lessThan(this.gestureX, 0)\r\n          : greaterThan(this.gestureX, 0),\r\n        // Based on the direction of the gesture, determine if we're entering the previous or next screen\r\n        cond(neq(floor(this.position), this.lastEnteredIndex), [\r\n          set(this.lastEnteredIndex, floor(this.position)),\r\n          call([floor(this.position)], this.handleEnteredIndexChange),\r\n        ]),\r\n        cond(neq(ceil(this.position), this.lastEnteredIndex), [\r\n          set(this.lastEnteredIndex, ceil(this.position)),\r\n          call([ceil(this.position)], this.handleEnteredIndexChange),\r\n        ])\r\n      )\r\n    ),\r\n    onChange(\r\n      this.isSwiping,\r\n      // Listen to updates for this value only when it changes\r\n      // Without `onChange`, this will fire even if the value didn't change\r\n      // We don't want to call the listeners if the value didn't change\r\n      [\r\n        cond(not(this.isSwiping), set(this.gesturesEnabled, 1)),\r\n        call(\r\n          [this.isSwiping, this.indexAtSwipeEnd, this.index],\r\n          ([isSwiping, indexAtSwipeEnd, currentIndex]: readonly number[]) => {\r\n            const {\r\n              keyboardDismissMode,\r\n              onSwipeStart,\r\n              onSwipeEnd,\r\n            } = this.props;\r\n\r\n            if (isSwiping === TRUE) {\r\n              onSwipeStart?.();\r\n              this.interactionHandle = InteractionManager.createInteractionHandle();\r\n\r\n              if (keyboardDismissMode === 'auto') {\r\n                // @ts-ignore: the method is only available in newer React Native, but types aren't up-to-date\r\n                const input = TextInput.State.currentlyFocusedInput\r\n                  ? // @ts-ignore\r\n                    TextInput.State.currentlyFocusedInput()\r\n                  : TextInput.State.currentlyFocusedField();\r\n\r\n                // When a gesture begins, blur the currently focused input\r\n                TextInput.State.blurTextInput(input);\r\n\r\n                // Store the id of this input so we can refocus it if gesture was cancelled\r\n                this.previouslyFocusedTextInput = input;\r\n              } else if (keyboardDismissMode === 'on-drag') {\r\n                Keyboard.dismiss();\r\n              }\r\n            } else {\r\n              onSwipeEnd?.();\r\n\r\n              if (this.interactionHandle !== null) {\r\n                InteractionManager.clearInteractionHandle(\r\n                  this.interactionHandle\r\n                );\r\n              }\r\n\r\n              if (keyboardDismissMode === 'auto') {\r\n                if (indexAtSwipeEnd === currentIndex) {\r\n                  // The index didn't change, we should restore the focus of text input\r\n                  const input = this.previouslyFocusedTextInput;\r\n\r\n                  if (input) {\r\n                    TextInput.State.focusTextInput(input);\r\n                  }\r\n                }\r\n\r\n                this.previouslyFocusedTextInput = null;\r\n              }\r\n            }\r\n          }\r\n        ),\r\n      ]\r\n    ),\r\n    onChange(\r\n      this.nextIndex,\r\n      cond(neq(this.nextIndex, UNSET), [\r\n        // Stop any running animations\r\n        cond(clockRunning(this.clock), stopClock(this.clock)),\r\n        set(this.gestureX, 0),\r\n        // Update the index to trigger the transition\r\n        set(this.index, this.nextIndex),\r\n        set(this.nextIndex, UNSET),\r\n      ])\r\n    ),\r\n    cond(\r\n      eq(this.gestureState, State.ACTIVE),\r\n      [\r\n        this.maybeCancel,\r\n        cond(this.isSwiping, NOOP, [\r\n          // We weren't dragging before, set it to true\r\n          set(this.isSwiping, TRUE),\r\n          set(this.isSwipeGesture, TRUE),\r\n          // Also update the drag offset to the last progress\r\n          set(this.offsetX, this.progress),\r\n        ]),\r\n        // Update progress with previous offset + gesture distance\r\n        set(\r\n          this.progress,\r\n          I18nManager.isRTL\r\n            ? sub(this.offsetX, this.gestureX)\r\n            : add(this.offsetX, this.gestureX)\r\n        ),\r\n        // Stop animations while we're dragging\r\n        stopClock(this.clock),\r\n      ],\r\n      [\r\n        set(this.isSwiping, FALSE),\r\n        set(this.indexAtSwipeEnd, this.index),\r\n        this.transitionTo(\r\n          cond(\r\n            and(\r\n              // We should consider velocity and gesture distance only when a swipe ends\r\n              // The gestureX value will be non-zero when swipe has happened\r\n              // We check against a minimum distance instead of 0 because `activeOffsetX` doesn't seem to be respected on Android\r\n              // For other factors such as state update, the velocity and gesture distance don't matter\r\n              greaterThan(abs(this.gestureX), SWIPE_DISTANCE_MINIMUM),\r\n              greaterThan(\r\n                abs(this.extrapolatedPosition),\r\n                divide(this.layoutWidth, 2)\r\n              )\r\n            ),\r\n            // For swipe gesture, to calculate the index, determine direction and add to index\r\n            // When the user swipes towards the left, we transition to the next tab\r\n            // When the user swipes towards the right, we transition to the previous tab\r\n            round(\r\n              min(\r\n                max(\r\n                  0,\r\n                  sub(\r\n                    this.index,\r\n                    cond(\r\n                      greaterThan(this.extrapolatedPosition, 0),\r\n                      I18nManager.isRTL ? DIRECTION_RIGHT : DIRECTION_LEFT,\r\n                      I18nManager.isRTL ? DIRECTION_LEFT : DIRECTION_RIGHT\r\n                    )\r\n                  )\r\n                ),\r\n                sub(this.routesLength, 1)\r\n              )\r\n            ),\r\n            // Index didn't change/changed due to state update\r\n            this.index\r\n          )\r\n        ),\r\n      ]\r\n    ),\r\n    this.progress,\r\n  ]);\r\n\r\n  private getTranslateX = memoize(\r\n    (\r\n      layoutWidth: Animated.Node<number>,\r\n      routesLength: Animated.Node<number>,\r\n      translateX: Animated.Node<number>\r\n    ) =>\r\n      multiply(\r\n        // Make sure that the translation doesn't exceed the bounds to prevent overscrolling\r\n        min(\r\n          max(\r\n            multiply(layoutWidth, sub(routesLength, 1), DIRECTION_RIGHT),\r\n            translateX\r\n          ),\r\n          0\r\n        ),\r\n        I18nManager.isRTL ? -1 : 1\r\n      )\r\n  );\r\n\r\n  render() {\r\n    const {\r\n      layout,\r\n      navigationState,\r\n      swipeEnabled,\r\n      children,\r\n      removeClippedSubviews,\r\n      gestureHandlerProps,\r\n    } = this.props;\r\n\r\n    const translateX = this.getTranslateX(\r\n      this.layoutWidth,\r\n      this.routesLength,\r\n      this.translateX\r\n    );\r\n\r\n    const animatedView = (children: any) => (\r\n      <Animated.View\r\n        removeClippedSubviews={removeClippedSubviews}\r\n        style={[\r\n          styles.container,\r\n          layout.width\r\n            ? {\r\n              width: layout.width * navigationState.routes.length,\r\n              transform: [{ translateX }] as any,\r\n            }\r\n            : null,\r\n        ]}\r\n      >\r\n        <PagerContext.Provider value={this.providerVal}>\r\n          <Text>Hello Test</Text>\r\n          {children}\r\n        </PagerContext.Provider>\r\n      </Animated.View>\r\n    );\r\n\r\n    const contentView = (children: any) => {\r\n      return swipeEnabled && this.state.enabled \r\n        ? (<PanGestureHandler\r\n            ref={this.gestureHandlerRef}\r\n            simultaneousHandlers={this.state.childPanGestureHandlerRefs}\r\n            waitFor={this.state.childPanGestureHandlerRefs}\r\n            enabled={layout.width !== 0 && swipeEnabled && this.state.enabled}\r\n            onGestureEvent={this.handleGestureEvent}\r\n            onHandlerStateChange={this.handleGestureEvent}\r\n            activeOffsetX={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\r\n            failOffsetY={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\r\n            {...gestureHandlerProps}\r\n          >\r\n            {animatedView(children)}\r\n          </PanGestureHandler>) \r\n        : animatedView(children)\r\n    }\r\n\r\n    return children({\r\n      position: this.position,\r\n      addListener: this.addListener,\r\n      removeListener: this.removeListener,\r\n      jumpTo: this.jumpTo,\r\n      render: (children: any) => contentView(children),\r\n    });\r\n  }\r\n}\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    flexDirection: 'row',\r\n  },\r\n});\r\n"]}